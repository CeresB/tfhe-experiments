#include <stdio.h>
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <cmath>
#include <sys/time.h>
#include <random>
// #include "lagrangehalfc_arithmetic.h"
// #include "lwe-functions.h"
// #include "lwebootstrappingkey.h"
// #include "lwekey.h"
// #include "lwekeyswitch.h"
// #include "lweparams.h"
// #include "lwesamples.h"
// #include "numeric_functions.h"
// #include "polynomials_arithmetic.h"
// #include "polynomials.h"
// #include "tfhe_core.h"
// #include "tfhe_garbage_collector.h"
// #include "tfhe_gate_bootstrapping_functions.h"
// #include "tfhe_gate_bootstrapping_structures.h"
// #include "tfhe_generic_streams.h"
// #include "tfhe_generic_templates.h"
// #include "tfhe_io.h"
#include "tfhe.h"
// #include "tlwe.h"
// #include "tlwe_functions.h"
// #include "tgsw.h"
// #include "tgsw_functions.h"
// #include "../libtfhe/autogenerated.cpp"

using namespace std;



int32_t main(int32_t argc, char **argv) {
    cout << "lets start" << endl;

    // parameter source: https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/shortint/parameters/parameters_wopbs_message_carry.rs
    // i chose: MESSAGE_3_CARRY_4. The authors claim its 123 to 128 bit secure.
    // means: 3 message-bits, 3 carry-bits = mult of two 3-bit values is possible
    const int32_t lwe_dimension = 481;
    const int32_t glwe_dimension = 2; //< number of polynomials in the mask // mask = A. Only needed for GLWE
    const int32_t polynomial_size = 1024; //< a power of 2: degree of the polynomials // each coefficient is one message in tlwe
    const double lwe_noise_distribution_stdev = 0.00061200133780220371345;
    const double glwe_noise_distribution = 0.00000000000000022148688116005568513645324585951;
    const int32_t pbs_base_log = 11; // pbs = programmable bootstrapping
    const int32_t pbs_level = 3;
    const int32_t ks_level = 9; // key switch
    const int32_t ks_base_log = 1;
    //const int32_t pfks_level = 3; // public functional key switch
    //const int32_t pfks_base_log = 11;
    //const int32_t pfks_noise_distribution_mu = 0.00000000000000022148688116005568513645324585951;
    const int32_t cbs_level = 5; // circuit bootstrapping --> macht Lwe zu gsw
    const int32_t cbs_base_log = 4;
    const int32_t message_modulus = 8; //number of possible message values: 0 to 7
    const int32_t carry_modulus = 16;

    const double alpha_min = 0.0;
    const double alpha = lwe_noise_distribution_stdev; 
    const double alpha_max = 1.0;

    int32_t decomposition_length = cbs_level;
    int32_t decomposition_Bgbit = cbs_base_log; // Bg = decomposition matrix
    int32_t ks_basebit = ks_base_log;

    // PARAMETERS
    LweParams *lwe_params = new_LweParams(lwe_dimension, alpha_min, alpha_max);
    TLweParams *tlwe_params = new_TLweParams(polynomial_size, glwe_dimension, alpha_min, alpha_max); //les deux alpha mis un peu au hasard
    TGswParams *tgsw_params = new_TGswParams(decomposition_length, decomposition_Bgbit, tlwe_params); // unsure about the params
    // generate placeholders
    LweKey *lwe_key = new_LweKey(lwe_params);
    TLweKey *tlwe_key = new_TLweKey(tlwe_params);
    TGswKey *tgsw_key = new_TGswKey(tgsw_params);
    // plaintext placeholders
    int32_t plaintext_result = 0;
    int32_t message_0 = 2;
    int32_t message_1 = 2;
    int32_t p = 2; // factor for AddMul
    TorusPolynomial *mu0 = new_TorusPolynomial(polynomial_size); 
    TorusPolynomial *mu1 = new_TorusPolynomial(polynomial_size);
    TorusPolynomial *mu = new_TorusPolynomial(polynomial_size); // intermediate value
    IntPolynomial *p_polym = new_IntPolynomial(polynomial_size);
    // ciphertext placeholders
    LweSample *cipher0_lwe = new_LweSample(lwe_params);
    LweSample *cipher1_lwe = new_LweSample(lwe_params);
    LweSample *cipher_lwe = new_LweSample(lwe_params); // intermediate value
    TLweSample *cipher0_tlwe = new_TLweSample(tlwe_params);
    TLweSample *cipher1_tlwe = new_TLweSample(tlwe_params);
    TLweSample *cipher_tlwe = new_TLweSample(tlwe_params); // intermediate value

    // key generation
    lweKeyGen(lwe_key);
    tLweKeyGen(tlwe_key);

    // messag space
    int32_t msg0_arr[] = {0,1,2,3,4,5,6,7};
    int32_t msg1_arr[] = {0,1,2,3,4,5,6,7};

    int32_t op_id = 0;
    clock_t cstart, cend;
    char op_names[6][5] = {" + ", " - ", " +2*", " -2*", " * ", "none"};
    cstart = clock();


    for (int32_t h = 0; h < 800; h++) {

        // msg generation lwe
        message_0 = msg0_arr[h%8];
        message_1 = msg1_arr[h%8];
        int32_t msg0_torus = modSwitchToTorus32(message_0, message_modulus);
        int32_t msg1_torus = modSwitchToTorus32(message_1, message_modulus);
        // lwe encryption  
        lweClear(cipher0_lwe, lwe_params);  
        lweClear(cipher1_lwe, lwe_params);
        lweClear(cipher_lwe, lwe_params);
        lweSymEncrypt(cipher0_lwe, msg0_torus, alpha, lwe_key);
        lweSymEncrypt(cipher1_lwe, msg1_torus, alpha, lwe_key);
        // msg generation tlwe (just lwe copied over and over again)
        torusPolynomialClear(mu0);
        torusPolynomialClear(mu1);
        torusPolynomialClear(mu);
        for (int32_t i = 0; i < mu0->N; ++i) { 
            mu0->coefsT[i] = msg0_torus;
            mu1->coefsT[i] = msg1_torus;
            p_polym->coefs[i] = p % message_modulus;
        }
        // tlwe encryption
        tLweClear(cipher0_tlwe, tlwe_params);
        tLweClear(cipher1_tlwe, tlwe_params);
        tLweClear(cipher_tlwe, tlwe_params);
        tLweSymEncrypt(cipher0_tlwe, mu0, alpha, tlwe_key);
        tLweSymEncrypt(cipher1_tlwe, mu1, alpha, tlwe_key);

        for(int32_t j=0; j<1000; j++){
            op_id = j % 4;
            lweCopy(cipher_lwe, cipher0_lwe, lwe_params);
            tLweCopy(cipher_tlwe, cipher0_tlwe, tlwe_params);

            switch(op_id) {
                case 0:
                    tLweAddTo(cipher_tlwe, cipher1_tlwe, tlwe_params);
                    break;
                case 1:
                    tLweSubTo(cipher_tlwe, cipher1_tlwe, tlwe_params);
                    break;
                case 2:
                    tLweAddMulTo(cipher_tlwe, p, cipher1_tlwe, tlwe_params);
                    break;
                case 3:
                    tLweSubMulTo(cipher_tlwe, p, cipher1_tlwe, tlwe_params);
                    break;            
                default:
                    break;
            }

            // switch(op_id) {
            //     case 0:
            //         lweAddTo(cipher_lwe, cipher1_lwe, lwe_params);
            //         break;
            //     case 1:
            //         lweSubTo(cipher_lwe, cipher1_lwe, lwe_params);
            //         break;
            //     case 2:
            //         lweAddMulTo(cipher_lwe, p, cipher1_lwe, lwe_params);
            //         break;
            //     case 3:
            //         lweSubMulTo(cipher_lwe, p, cipher1_lwe, lwe_params);
            //         break;            
            //     default:
            //         break;
            // }
        }
    }

    // decrypt
    int32_t dec_num = 0; // temp decryption value
    // decrypt lwe sample
    int32_t res_torus_lwe = lweSymDecrypt(cipher_lwe, lwe_key, message_modulus);
    dec_num = modSwitchFromTorus32(res_torus_lwe, message_modulus);
    // decrypt first tlwe sample
    tLweSymDecrypt(mu, cipher_tlwe, tlwe_key, message_modulus);
    dec_num = modSwitchFromTorus32(mu->coefsT[0], message_modulus);
    
    cout << "----------------------" << endl;
    cend = clock();
    int32_t cyc = cend - cstart;
    cout << "cycles needed for operation: " << cyc << endl;

    
    delete_TLweSample(cipher0_tlwe);
    delete_LweSample(cipher_lwe);
    delete_TLweSample(cipher_tlwe);
    delete_TLweSample(cipher1_tlwe);
    delete_LweSample(cipher1_lwe);
    delete_LweSample(cipher0_lwe);
    delete_IntPolynomial(p_polym);
    delete_TorusPolynomial(mu);
    delete_TorusPolynomial(mu1);
    delete_TorusPolynomial(mu0);
    delete_TLweKey(tlwe_key);
    delete_LweKey(lwe_key);
    // the parameters are used in different deconstructors and must be deleted last
    delete_TLweParams(tlwe_params);
    delete_LweParams(lwe_params);

    return 0;
}
